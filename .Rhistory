detectability <- 2
sig.disp <- 32.5*times/(times+6.35)
#rexp(nperiods, .2) %>% sort(decreasing = TRUE) %>% cumsum() %>% sort() #rep(20, nperiods)
t.max <- 4.22/(-log(survival)*365)
overdispersion <- 2
nreps <- 500
nmods <- 3
count.mat.sim <- array(0, dim = c(nmods, nsites*nperiods, ntraps),
dimnames = list(mod=NULL, site.period = NULL, trap=NULL))
fitted.mods <- list()
for(sim.mod in 1:nmods) {
fitted.mods[[sim.mod]] <- list()
for(est.mod in 1:(nmods+1)) {
fitted.mods[[sim.mod]][[est.mod]] <- list()
}
}
simulate.counts <- function(distance, times, disp.mod, ntraps, nrel, survival, detectability,
overdispersion = NA, half.distn, ...) {
## Take dispersal model choice, other parameters, to simulate observed counts at each of
## ntraps traps. Returns vector of length ntraps.
## If overdispersion parameter is numeric, simulates negative binomials counts.
## Otherwise (NA, NULL, FALSE, etc.) simulates Poison counts.
dist.factor <- (1+half.distn) * disp.mod(distance, ...)
pred.count <- nrel * survival^times * detectability * dist.factor
if(is.numeric(overdispersion)) {
counts <- rnbinom(ntraps, mu = pred.count, size = overdispersion)
} else {
counts <- rpois(ntraps, pred.count)
}
return(counts)
}
Parameters <- list(
logit_survival = log(.99/.01),
log_detectability = log(2),
log_sig_disp_mu = log(20),
log_sig_disp_sig = log(1),
log_sig_disp_eps = rep(0, 9),
log_overdispersion = log(2)
)
disp.mods <- c('normal', 'exponential', 'cauchy')
disp.structure <- c('constant', 'fixed', 'random', 'asympBH', 'asympVB')
for(ii in 1:nreps) {
# simulate data
ind <- 1
for(period in 1:nperiods) {
for(site in 1:nsites) {
# half-normal
count.mat.sim[1,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dnorm,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, mean = 0,
sd = sig.disp[period])
# exponential
count.mat.sim[2,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dexp,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = FALSE,
rate = 1/sig.disp[period])
# half-cauchy
count.mat.sim[3,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dcauchy,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, location = 0,
scale = sig.disp[period])
ind <- ind + 1
}
}
# fit data
for(sim.mod in 1:nmods) {
for(est.mod in 1:nmods) {
input.ls <- make.inputs(dat.ls = list(nrel = nrel,
nsites = nsites,
nperiods = nperiods,
ntraps = ntraps,
count.mat = count.mat.sim[sim.mod,,],
distances = distances,
times = times),
disp.model = disp.mods[est.mod],
count.model = 'neg.binom', dist.cutoff = 50,
sigma.type = 'constant')
model <- MakeADFun(data = input.ls$Data, parameters = Parameters,
map = input.ls$Map,
DLL="DM_MM_sig")
model$env$beSilent()
Opt = nlminb(start=model$par, objective=model$fn, gradient=model$gr)
fitted.mods[[sim.mod]][[est.mod]][[ii]] <- model
}
recaps <- apply(count.mat.sim[sim.mod,,], 1, sum) %>%
tapply(rep(1:nperiods, each=nsites), sum) %>% as.vector()
fitted.mods[[sim.mod]][[nmods+1]][[ii]] <- tryCatch(glm(recaps~times, family=poisson,
control = glm.control(maxit = 1000)),
error=function(e) return(NA),
warning=function(w) return(NA))
}
}
true.val.mat <- matrix(c(qnorm(.75, 0, sig.disp[1]),
2*(pnorm(50, 0, sig.disp[1]) - 0.5),
qexp(.5, 1/sig.disp[1]),
pexp(50, 1/sig.disp[1]),
qcauchy(.75, 0, sig.disp[1]),
2*(pcauchy(50, 0, sig.disp[1]) - 0.5)),
nrow=3, byrow=TRUE,
dimnames = list(model = disp.mods,
val = c('fifty_pct', 'pct_at_dist')))
res <- rmse <- mare <- temp <- list()
aic.sim <- array(0, dim=c(nmods, nmods+1, nreps),
dimnames=list(sim.mod=disp.mods, est.mod=c(disp.mods, 'no dispersal'),
rep=1:nreps))
for(sim.mod in 1:nmods) {
res[[sim.mod]] <- rmse[[sim.mod]] <- mare[[sim.mod]] <- list()
for(est.mod in 1:nmods) {
sdreports <- sapply(fitted.mods[[sim.mod]][[est.mod]], sdreport)
res[[sim.mod]][[est.mod]] <- apply(sdreports, 2,
function(x)
x['value']$value[c('t_max', 'fifty_pct', 'pct_at_dist')]) %>%
t()
err <- t(res[[sim.mod]][[est.mod]]) - c(t.max, true.val.mat[sim.mod,])
rel.err <- err/c(t.max, true.val.mat[sim.mod,])
rmse[[sim.mod]][[est.mod]] <- apply(err, 1, function(x) sqrt(mean(x^2)))
mare[[sim.mod]][[est.mod]] <- apply(rel.err, 1, function(x) median(abs(x)))
aic.sim[sim.mod, est.mod,] <- sapply(fitted.mods[[sim.mod]][[est.mod]],
function(x) 2*3 + 2*x$fn())
}
res[[sim.mod]][[4]] <- sapply(fitted.mods[[sim.mod]][[4]],
function(x) tryCatch(c(-4.22/(coef(x)['times']*365), NA, NA),
# S = exp(nb glm estimate)
# M = -log(S)
# convert daily to annual rate
# convert to max age
error=function(e) return(c(NA,NA,NA)))) %>%
matrix(ncol=3, byrow=TRUE)
err <- res[[sim.mod]][[4]] - t.max
rel.err <- err/t.max
rmse[[sim.mod]][[4]] <- apply(err, 1, function(x) sqrt(mean(x^2)))
mare[[sim.mod]][[4]] <- apply(rel.err, 1, function(x) median(abs(x)))
aic.sim[sim.mod, 4,] <- sapply(fitted.mods[[sim.mod]][[4]], function(mod)
if(length(mod)>1) return(AIC(mod)) else return(NA))
temp[[sim.mod]] <- do.call(rbind, res[[sim.mod]]) %>% data.frame() %>%
mutate(est.mod = rep(c(disp.mods, 'no dispersal'), each=nreps))
}
res.df <- do.call(rbind, temp) %>%
mutate(sim.mod = rep(disp.mods, each=nreps*(nmods+1))) #%>% rename(surv = survival)
plot.sims <- function(rel.err.df, col, offset) {
dark.col <- stringr::str_replace(gplots::col2hex(col), 'FF', '99')
abline(v=offset, lty=3, col='black')
summary.stat.temp <- group_by(rel.err.df, est.mod) %>%
do(quants=quantile(.$rel.err, probs = c(.025, .25, .5, .75, .975), na.rm=TRUE))
summary.stat <- summary.stat.temp[match(c(disp.mods, 'no dispersal'), summary.stat.temp$est.mod),] %>%
filter(!is.na(est.mod))
mapply(function(x,y) {
segments(x[1:2] + offset, y, x[5:4] + offset, y, lwd=2,
col=c('grey80', dark.col))
points(x[3] + offset, y, pch=21, col=dark.col, bg=col)},
summary.stat$quants, length(summary.stat$quants):1)
}
max1=.3
max2=.35
max3=.75
# big.df <- res.df
# res.df <- filter(res.df, est.mod != 'no dispersal')
par(mfrow=c(n_distinct(res.df$sim.mod),1), mar=rep(.5, 4), oma=c(5,6,4,1))
plot.max <- n_distinct(res.df$est.mod) + 0.5
for(mod in disp.mods) {
plot(1,1, xlim=c(-max1, max1+max2+2*max3), ylim=c(.5, plot.max),
type='n', axes=FALSE, ann=FALSE)
text(-.7, plot.max+0.2, Hmisc::capitalize(mod), xpd=NA, pos=4)
text(-.63, (plot.max-0.5):1, Hmisc::capitalize(c(disp.mods, 'no dispersal')), xpd=NA, pos=4)
if(mod==disp.mods[1]) {
text(c(0, max1+max2, max1+max2+max3), plot.max, xpd=NA, pos=3, offset=2,
c('T max', '% w/in 50m', 'Dist @ 50%'),
col=stringr::str_replace(gplots::col2hex(c('red', 'blue', 'green')), 'FF', '99'))
}
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (t_max-t.max) / t.max) %>%
plot.sims(col='red', offset=0)
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (pct_at_dist-true.val.mat[sim.mod,'pct_at_dist']) /
true.val.mat[sim.mod,'pct_at_dist']) %>%
plot.sims(col='blue', offset=max1+max2)
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (fifty_pct-true.val.mat[sim.mod,'fifty_pct']) /
true.val.mat[sim.mod,'fifty_pct']) %>%
plot.sims(col='green', offset=max1+max2+max3)
}
box('inner')
axis(1, at=max1+max2+max3+c(0, .25, .5), labels = c('', 0.25, 0.5), line = 1)
axis(1, at=max1+max2+c(0, .2, .4), labels=c('', .2, .4), line=1)
axis(1, at=c(0, .2), labels=c('', .2), line=1)
mtext('Relative error', 1, 3, outer=TRUE)
require(TMB)
require(MASS)
set.seed(789890235)
dyn.load(dynlib("DM_MM_sig"))
# Data structure
dat <- read.data('Data/crk2.dat')
ncreeks <- dat$ncreeks
nrel <- dat$nrel
nsites <- dat$nsites
nperiods <- dat$nperiods
ntraps <- dat$ntraps
distances <- dat$distances
times <- dat$times
# True values
survival <- 0.99
detectability <- 2
# sig.disp <- 32.5*times/(times+6.35)
sig. disp <- rexp(nperiods, .2) %>% sort(decreasing = TRUE) %>% cumsum() %>% sort() #rep(20, nperiods)
t.max <- 4.22/(-log(survival)*365)
overdispersion <- 2
nreps <- 100
nmods <- 3
count.mat.sim <- array(0, dim = c(nmods, nsites*nperiods, ntraps),
dimnames = list(mod=NULL, site.period = NULL, trap=NULL))
fitted.mods <- list()
for(sim.mod in 1:nmods) {
fitted.mods[[sim.mod]] <- list()
for(est.mod in 1:(nmods+1)) {
fitted.mods[[sim.mod]][[est.mod]] <- list()
}
}
simulate.counts <- function(distance, times, disp.mod, ntraps, nrel, survival, detectability,
overdispersion = NA, half.distn, ...) {
## Take dispersal model choice, other parameters, to simulate observed counts at each of
## ntraps traps. Returns vector of length ntraps.
## If overdispersion parameter is numeric, simulates negative binomials counts.
## Otherwise (NA, NULL, FALSE, etc.) simulates Poison counts.
dist.factor <- (1+half.distn) * disp.mod(distance, ...)
pred.count <- nrel * survival^times * detectability * dist.factor
if(is.numeric(overdispersion)) {
counts <- rnbinom(ntraps, mu = pred.count, size = overdispersion)
} else {
counts <- rpois(ntraps, pred.count)
}
return(counts)
}
Parameters <- list(
logit_survival = log(.99/.01),
log_detectability = log(2),
log_sig_disp_mu = log(20),
log_sig_disp_sig = log(1),
log_sig_disp_eps = rep(0, 9),
log_overdispersion = log(2)
)
disp.mods <- c('normal', 'exponential', 'cauchy')
disp.structure <- c('constant', 'fixed', 'random', 'asympBH', 'asympVB')
for(ii in 1:nreps) {
# simulate data
ind <- 1
for(period in 1:nperiods) {
for(site in 1:nsites) {
# half-normal
count.mat.sim[1,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dnorm,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, mean = 0,
sd = sig.disp[period])
# exponential
count.mat.sim[2,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dexp,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = FALSE,
rate = 1/sig.disp[period])
# half-cauchy
count.mat.sim[3,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dcauchy,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, location = 0,
scale = sig.disp[period])
ind <- ind + 1
}
}
# fit data
for(sim.mod in 1:nmods) {
for(est.mod in 1:nmods) {
input.ls <- make.inputs(dat.ls = list(nrel = nrel,
nsites = nsites,
nperiods = nperiods,
ntraps = ntraps,
count.mat = count.mat.sim[sim.mod,,],
distances = distances,
times = times),
disp.model = disp.mods[est.mod],
count.model = 'neg.binom', dist.cutoff = 50,
sigma.type = 'constant')
model <- MakeADFun(data = input.ls$Data, parameters = Parameters,
map = input.ls$Map,
DLL="DM_MM_sig")
model$env$beSilent()
Opt = nlminb(start=model$par, objective=model$fn, gradient=model$gr)
fitted.mods[[sim.mod]][[est.mod]][[ii]] <- model
}
recaps <- apply(count.mat.sim[sim.mod,,], 1, sum) %>%
tapply(rep(1:nperiods, each=nsites), sum) %>% as.vector()
fitted.mods[[sim.mod]][[nmods+1]][[ii]] <- tryCatch(glm(recaps~times, family=poisson,
control = glm.control(maxit = 1000)),
error=function(e) return(NA),
warning=function(w) return(NA))
}
}
require(TMB)
require(MASS)
set.seed(789890235)
dyn.load(dynlib("DM_MM_sig"))
# Data structure
dat <- read.data('Data/crk2.dat')
ncreeks <- dat$ncreeks
nrel <- dat$nrel
nsites <- dat$nsites
nperiods <- dat$nperiods
ntraps <- dat$ntraps
distances <- dat$distances
times <- dat$times
# True values
survival <- 0.99
detectability <- 2
# sig.disp <- 32.5*times/(times+6.35)
sig.disp <- rexp(nperiods, .2) %>% sort(decreasing = TRUE) %>% cumsum() %>% sort() #rep(20, nperiods)
t.max <- 4.22/(-log(survival)*365)
overdispersion <- 2
nreps <- 100
nmods <- 3
count.mat.sim <- array(0, dim = c(nmods, nsites*nperiods, ntraps),
dimnames = list(mod=NULL, site.period = NULL, trap=NULL))
fitted.mods <- list()
for(sim.mod in 1:nmods) {
fitted.mods[[sim.mod]] <- list()
for(est.mod in 1:(nmods+1)) {
fitted.mods[[sim.mod]][[est.mod]] <- list()
}
}
simulate.counts <- function(distance, times, disp.mod, ntraps, nrel, survival, detectability,
overdispersion = NA, half.distn, ...) {
## Take dispersal model choice, other parameters, to simulate observed counts at each of
## ntraps traps. Returns vector of length ntraps.
## If overdispersion parameter is numeric, simulates negative binomials counts.
## Otherwise (NA, NULL, FALSE, etc.) simulates Poison counts.
dist.factor <- (1+half.distn) * disp.mod(distance, ...)
pred.count <- nrel * survival^times * detectability * dist.factor
if(is.numeric(overdispersion)) {
counts <- rnbinom(ntraps, mu = pred.count, size = overdispersion)
} else {
counts <- rpois(ntraps, pred.count)
}
return(counts)
}
Parameters <- list(
logit_survival = log(.99/.01),
log_detectability = log(2),
log_sig_disp_mu = log(20),
log_sig_disp_sig = log(1),
log_sig_disp_eps = rep(0, 9),
log_overdispersion = log(2)
)
disp.mods <- c('normal', 'exponential', 'cauchy')
disp.structure <- c('constant', 'fixed', 'random', 'asympBH', 'asympVB')
for(ii in 1:nreps) {
# simulate data
ind <- 1
for(period in 1:nperiods) {
for(site in 1:nsites) {
# half-normal
count.mat.sim[1,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dnorm,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, mean = 0,
sd = sig.disp[period])
# exponential
count.mat.sim[2,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dexp,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = FALSE,
rate = 1/sig.disp[period])
# half-cauchy
count.mat.sim[3,ind,] <- simulate.counts(distance = distances[site],
times=times[period], disp.mod = dcauchy,
ntraps = ntraps, nrel = nrel,
survival = survival,
detectability = detectability,
overdispersion = overdispersion,
half.distn = TRUE, location = 0,
scale = sig.disp[period])
ind <- ind + 1
}
}
# fit data
for(sim.mod in 1:nmods) {
for(est.mod in 1:nmods) {
input.ls <- make.inputs(dat.ls = list(nrel = nrel,
nsites = nsites,
nperiods = nperiods,
ntraps = ntraps,
count.mat = count.mat.sim[sim.mod,,],
distances = distances,
times = times),
disp.model = disp.mods[est.mod],
count.model = 'neg.binom', dist.cutoff = 50,
sigma.type = 'constant')
model <- MakeADFun(data = input.ls$Data, parameters = Parameters,
map = input.ls$Map,
DLL="DM_MM_sig")
model$env$beSilent()
Opt = nlminb(start=model$par, objective=model$fn, gradient=model$gr)
fitted.mods[[sim.mod]][[est.mod]][[ii]] <- model
}
recaps <- apply(count.mat.sim[sim.mod,,], 1, sum) %>%
tapply(rep(1:nperiods, each=nsites), sum) %>% as.vector()
fitted.mods[[sim.mod]][[nmods+1]][[ii]] <- tryCatch(glm(recaps~times, family=poisson,
control = glm.control(maxit = 1000)),
error=function(e) return(NA),
warning=function(w) return(NA))
}
}
true.val.mat <- matrix(c(qnorm(.75, 0, sig.disp[1]),
2*(pnorm(50, 0, sig.disp[1]) - 0.5),
qexp(.5, 1/sig.disp[1]),
pexp(50, 1/sig.disp[1]),
qcauchy(.75, 0, sig.disp[1]),
2*(pcauchy(50, 0, sig.disp[1]) - 0.5)),
nrow=3, byrow=TRUE,
dimnames = list(model = disp.mods,
val = c('fifty_pct', 'pct_at_dist')))
res <- rmse <- mare <- temp <- list()
aic.sim <- array(0, dim=c(nmods, nmods+1, nreps),
dimnames=list(sim.mod=disp.mods, est.mod=c(disp.mods, 'no dispersal'),
rep=1:nreps))
for(sim.mod in 1:nmods) {
res[[sim.mod]] <- rmse[[sim.mod]] <- mare[[sim.mod]] <- list()
for(est.mod in 1:nmods) {
sdreports <- sapply(fitted.mods[[sim.mod]][[est.mod]], sdreport)
res[[sim.mod]][[est.mod]] <- apply(sdreports, 2,
function(x)
x['value']$value[c('t_max', 'fifty_pct', 'pct_at_dist')]) %>%
t()
err <- t(res[[sim.mod]][[est.mod]]) - c(t.max, true.val.mat[sim.mod,])
rel.err <- err/c(t.max, true.val.mat[sim.mod,])
rmse[[sim.mod]][[est.mod]] <- apply(err, 1, function(x) sqrt(mean(x^2)))
mare[[sim.mod]][[est.mod]] <- apply(rel.err, 1, function(x) median(abs(x)))
aic.sim[sim.mod, est.mod,] <- sapply(fitted.mods[[sim.mod]][[est.mod]],
function(x) 2*3 + 2*x$fn())
}
res[[sim.mod]][[4]] <- sapply(fitted.mods[[sim.mod]][[4]],
function(x) tryCatch(c(-4.22/(coef(x)['times']*365), NA, NA),
# S = exp(nb glm estimate)
# M = -log(S)
# convert daily to annual rate
# convert to max age
error=function(e) return(c(NA,NA,NA)))) %>%
matrix(ncol=3, byrow=TRUE)
err <- res[[sim.mod]][[4]] - t.max
rel.err <- err/t.max
rmse[[sim.mod]][[4]] <- apply(err, 1, function(x) sqrt(mean(x^2)))
mare[[sim.mod]][[4]] <- apply(rel.err, 1, function(x) median(abs(x)))
aic.sim[sim.mod, 4,] <- sapply(fitted.mods[[sim.mod]][[4]], function(mod)
if(length(mod)>1) return(AIC(mod)) else return(NA))
temp[[sim.mod]] <- do.call(rbind, res[[sim.mod]]) %>% data.frame() %>%
mutate(est.mod = rep(c(disp.mods, 'no dispersal'), each=nreps))
}
res.df <- do.call(rbind, temp) %>%
mutate(sim.mod = rep(disp.mods, each=nreps*(nmods+1))) #%>% rename(surv = survival)
par(mfrow=c(n_distinct(res.df$sim.mod),1), mar=rep(.5, 4), oma=c(5,6,4,1))
plot.max <- n_distinct(res.df$est.mod) + 0.5
for(mod in disp.mods) {
plot(1,1, xlim=c(-max1, max1+max2+2*max3), ylim=c(.5, plot.max),
type='n', axes=FALSE, ann=FALSE)
text(-.7, plot.max+0.2, Hmisc::capitalize(mod), xpd=NA, pos=4)
text(-.63, (plot.max-0.5):1, Hmisc::capitalize(c(disp.mods, 'no dispersal')), xpd=NA, pos=4)
if(mod==disp.mods[1]) {
text(c(0, max1+max2, max1+max2+max3), plot.max, xpd=NA, pos=3, offset=2,
c('T max', '% w/in 50m', 'Dist @ 50%'),
col=stringr::str_replace(gplots::col2hex(c('red', 'blue', 'green')), 'FF', '99'))
}
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (t_max-t.max) / t.max) %>%
plot.sims(col='red', offset=0)
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (pct_at_dist-true.val.mat[sim.mod,'pct_at_dist']) /
true.val.mat[sim.mod,'pct_at_dist']) %>%
plot.sims(col='blue', offset=max1+max2)
temp <- filter(res.df, sim.mod==mod)  %>%
mutate(rel.err = (fifty_pct-true.val.mat[sim.mod,'fifty_pct']) /
true.val.mat[sim.mod,'fifty_pct']) %>%
plot.sims(col='green', offset=max1+max2+max3)
}
box('inner')
axis(1, at=max1+max2+max3+c(0, .25, .5), labels = c('', 0.25, 0.5), line = 1)
axis(1, at=max1+max2+c(0, .2, .4), labels=c('', .2, .4), line=1)
axis(1, at=c(0, .2), labels=c('', .2), line=1)
mtext('Relative error', 1, 3, outer=TRUE)
